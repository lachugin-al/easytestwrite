package utils

/**
 * Универсальный парсер чисел из «грязного» текста (цены/суммы).
 * ----------------------------------------------------------------------------
 * RU:
 * Извлекает первое числовое значение из произвольной строки и приводит его к Double.
 * Подходит для цен/сумм, в которых могут встречаться неразрывные и тонкие пробелы,
 * валютные символы, апострофы, смешанные разделители тысяч и десятичные разделители.
 *
 * Что делает:
 *  - Нормализует «спец-пробелы» (NBSP, thin space и т. п.) в обычный пробел
 *  - Выделяет первый числовой токен, отбрасывая валютные/текстовые «хвосты»
 *  - Эвристически определяет десятичный разделитель (запятая или точка)
 *  - Удаляет разделители тысяч (пробелы, апострофы, лишние точки/запятые)
 *
 * Эвристика разделителей:
 *  - Если присутствуют и запятая, и точка — десятичным считается тот, что стоит правее.
 *    Второй трактуется как разделитель тысяч и удаляется.
 *  - Если присутствует только один из {',' '.'}, то:
 *      * если последний «кусок» после разделителя имеет длину 3 и есть другие группы из 3,
 *        разделитель, вероятно, тысячный → удаляется;
 *      * иначе — считается десятичным.
 *
 * Примеры:
 *  - "€1 234,56"        → 1234.56
 *  - "USD 12,345.70"    → 12345.70
 *  - "1.234,56 ₽"       → 1234.56
 *  - "- 3’141’592,65"   → -3141592.65
 *  - "≈2.000"           → 2000.0
 *  - "2,000"            → 2000.0   (трактуется как разделитель тысяч)
 *  - "0,99 kg"          → 0.99
 *  - "abc"              → null
 *
 * Ограничения:
 *  - Разбирается только первое числовое вхождение.
 *  - Научная нотация (например, "1e3") не поддерживается.
 *  - Экзотические группировки, отличные от пробела/апострофа/точки/запятой, не учитываются.
 *  - Локальные правила форматирования могут отличаться от применённой эвристики.
 *
 * Сложность:
 *  - Временная — O(n) по длине входной строки; дополнительная память — O(n).
 *
 * Пример использования (вывод в консоль — на английском):
 * ```
 * fun main() {
 *     val samples = listOf("€1 234,56", "USD 12,345.70", "abc")
 *     for (s in samples) {
 *         println("Input: \"$s\" -> ${NumberParser.parseNumber(s)}")
 *     }
 * }
 * // Output:
 * // Input: "€1 234,56" -> 1234.56
 * // Input: "USD 12,345.70" -> 12345.7
 * // Input: "abc" -> null
 * ```
 */
object NumberParser {
    // Специальные пробелы, которые приводим к обычному пробелу
    private val spaceChars = "\u00A0\u202F\u2009\u2007\u2060\u2002\u2003\u2004\u2005\u2006\u2008\u3000"

    /**
     * RU: Парсит Double из любой строки, содержащей число. Возвращает null, если число
     * не найдено или распознать не удалось.
     *
     * @param text Входная строка (может быть null)
     * @return Распознанное значение Double или null
     */
    fun parseNumber(text: String?): Double? {
        if (text == null) return null
        if (text.isBlank()) return null

        // Нормализуем юникод-пробелы в обычный пробел
        val normalized = text.map { ch -> if (spaceChars.contains(ch)) ' ' else ch }.joinToString("")

        // Находим первый числовой токен с возможными разделителями тысяч/десятичными
        val regex = Regex("[-+]?\\d[\\d\\s'.,]*")
        val match = regex.find(normalized) ?: return null
        var token = match.value.trim()
        if (token.isEmpty()) return null

        // Удаляем ведущий плюс
        token = token.removePrefix("+")

        // Схлопываем множественные пробелы
        token = token.replace(Regex("\\s+"), " ")

        // Эвристически определяем десятичный разделитель и парсим
        return parseTokenToDouble(token)
    }

    /**
     * RU: Преобразует выделенный числовой токен в Double, применяя эвристику выбора
     * десятичного разделителя и удаляя разделители тысяч.
     *
     * Детали:
     *  - Если есть и ',' и '.', десятичным считается последний встреченный символ.
     *  - Если есть только один из них, анализируются группы между разделителями:
     *      * если «средние» группы имеют длину 3 и последний фрагмент длиной 3 — считаем это
     *        группировкой тысяч;
     *      * иначе — рассматриваем разделитель как десятичный.
     */
    private fun parseTokenToDouble(raw: String): Double? {
        var token = raw
        val hasComma = token.contains(',')
        val hasDot = token.contains('.')

        // Сначала удаляем пробелы и апострофы как потенциальные разделители тысяч
        token = token.replace(" ", "").replace("'", "")

        var decimalSep: Char? = null
        if (hasComma && hasDot) {
            // Оба присутствуют: правый — десятичный, другой — тысячный
            val lastComma = token.lastIndexOf(',')
            val lastDot = token.lastIndexOf('.')
            decimalSep = if (lastComma > lastDot) ',' else '.'
        } else if (hasComma xor hasDot) {
            val sep = if (hasComma) ',' else '.'
            val parts = token.split(sep)
            if (parts.size == 1) {
                decimalSep = null
            } else {
                val lastPart = parts.last()
                // Если есть >1 разделителя и все средние группы длиной 3 — вероятно, это тысячи
                val middleGroups = parts.drop(1).dropLast(1)
                val allMiddleAre3 = middleGroups.isNotEmpty() && middleGroups.all { it.length == 3 }
                decimalSep = when {
                    // Предпочитаем трактовку «тысячи», когда последний фрагмент длиной 3
                    // и есть иные группы/средние группы по 3 символа
                    lastPart.length == 3 && (parts.size > 2 || allMiddleAre3) -> null
                    // иначе — это десятичный разделитель
                    else -> sep
                }
            }
        }

        // Удаляем все не-десятичные разделители (точки/запятые, использованные как тысячи)
        token = when (decimalSep) {
            ',' -> token.replace(".", "")
            '.' -> token.replace(",", "")
            else -> token.replace(",", "").replace(".", "")
        }

        // Если десятичный разделитель определён, сохраняем только последний и заменяем на точку
        if (decimalSep != null) {
            val sep = decimalSep!!
            val lastIndex = token.lastIndexOf(sep)
            if (lastIndex >= 0) {
                val before = token.substring(0, lastIndex).replace(sep.toString(), "")
                val after = token.substring(lastIndex + 1)
                token = before + '.' + after
            } else {
                // Запасной путь (если вдруг разделитель не найден)
                token = token.replace(sep, '.')
            }
        }

        // Ожидаемый итог: -?\\d+(\\.\\d+)?
        return token.toDoubleOrNull()
    }
}
